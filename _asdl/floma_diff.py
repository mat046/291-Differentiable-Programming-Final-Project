"""
ASDL Module generated by asdl_adt
Original ASDL description:

module floma_diff {
     func = FunctionDef ( string id, arg* args, stmt* body, type? ret_type )
          | ReverseDiff ( string id, string primal_func )
          attributes  ( int? lineno )

     stmt = Assign     ( expr target, expr val )
          | Declare    ( string target, type t, expr? val )
          | CallStmt   ( expr call )
          | Return     ( expr val )
          attributes   ( int? lineno )

     expr = Var          ( string id )
          | StructAccess ( expr struct, string member_id )
          | ConstFloat   ( float val )
          | BinaryOp     ( bin_op op, expr left, expr right )
          | Call         ( string id, expr* args )
          | ContExpr     ( arg a, expr* captures, expr? body )
          attributes     ( int? lineno, type? t )

     arg  = Arg ( string id, type t )

     type = Float  ( )
          | Struct ( string id, struct_member* members, int? lineno )
          | Cont   ( type arg_type )

     struct_member = MemberDef ( string id, type t )

     bin_op = Add()
          | Sub()
          | Mul()
          | Div()
}

"""
from __future__ import annotations
import attrs as _attrs
from typing import Tuple as _Tuple
from typing import Optional as _Optional


def _list_to_tuple(xs):
    return tuple(xs) if isinstance(xs, list) else xs


class func:

    def __init__(self, *args, **kwargs):
        assert False, "Cannot instantiate func"


@_attrs.define
class FunctionDef(func):
    id: str
    args: list[arg]
    body: list[stmt]
    ret_type: _Optional[type] = None
    lineno: _Optional[int] = None

    def __attrs_post_init__(self):
        if not isinstance(self.id, str):
            raise TypeError("FunctionDef(...) argument 1: " +
                            "invalid instance of 'string id'")
        if not (isinstance(self.args, (tuple, list))
                and all(isinstance(x, arg) for x in self.args)):
            raise TypeError("FunctionDef(...) argument 2: " +
                            "invalid instance of 'arg* args'")
        if not (isinstance(self.body, (tuple, list))
                and all(isinstance(x, stmt) for x in self.body)):
            raise TypeError("FunctionDef(...) argument 3: " +
                            "invalid instance of 'stmt* body'")
        if not (self.ret_type is None or isinstance(self.ret_type, type)):
            raise TypeError("FunctionDef(...) argument 4: " +
                            "invalid instance of 'type? ret_type'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("FunctionDef(...) argument 5: " +
                            "invalid instance of 'int? lineno'")


@_attrs.define
class ReverseDiff(func):
    id: str
    primal_func: str
    lineno: _Optional[int] = None

    def __attrs_post_init__(self):
        if not isinstance(self.id, str):
            raise TypeError("ReverseDiff(...) argument 1: " +
                            "invalid instance of 'string id'")
        if not isinstance(self.primal_func, str):
            raise TypeError("ReverseDiff(...) argument 2: " +
                            "invalid instance of 'string primal_func'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("ReverseDiff(...) argument 3: " +
                            "invalid instance of 'int? lineno'")


class stmt:

    def __init__(self, *args, **kwargs):
        assert False, "Cannot instantiate stmt"


@_attrs.define
class Assign(stmt):
    target: expr
    val: expr
    lineno: _Optional[int] = None

    def __attrs_post_init__(self):
        if not isinstance(self.target, expr):
            raise TypeError("Assign(...) argument 1: " +
                            "invalid instance of 'expr target'")
        if not isinstance(self.val, expr):
            raise TypeError("Assign(...) argument 2: " +
                            "invalid instance of 'expr val'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("Assign(...) argument 3: " +
                            "invalid instance of 'int? lineno'")


@_attrs.define
class Declare(stmt):
    target: str
    t: type
    val: _Optional[expr] = None
    lineno: _Optional[int] = None

    def __attrs_post_init__(self):
        if not isinstance(self.target, str):
            raise TypeError("Declare(...) argument 1: " +
                            "invalid instance of 'string target'")
        if not isinstance(self.t, type):
            raise TypeError("Declare(...) argument 2: " +
                            "invalid instance of 'type t'")
        if not (self.val is None or isinstance(self.val, expr)):
            raise TypeError("Declare(...) argument 3: " +
                            "invalid instance of 'expr? val'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("Declare(...) argument 4: " +
                            "invalid instance of 'int? lineno'")


@_attrs.define
class CallStmt(stmt):
    call: expr
    lineno: _Optional[int] = None

    def __attrs_post_init__(self):
        if not isinstance(self.call, expr):
            raise TypeError("CallStmt(...) argument 1: " +
                            "invalid instance of 'expr call'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("CallStmt(...) argument 2: " +
                            "invalid instance of 'int? lineno'")


@_attrs.define
class Return(stmt):
    val: expr
    lineno: _Optional[int] = None

    def __attrs_post_init__(self):
        if not isinstance(self.val, expr):
            raise TypeError("Return(...) argument 1: " +
                            "invalid instance of 'expr val'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("Return(...) argument 2: " +
                            "invalid instance of 'int? lineno'")


class expr:

    def __init__(self, *args, **kwargs):
        assert False, "Cannot instantiate expr"


@_attrs.define
class Var(expr):
    id: str
    lineno: _Optional[int] = None
    t: _Optional[type] = None

    def __attrs_post_init__(self):
        if not isinstance(self.id, str):
            raise TypeError("Var(...) argument 1: " +
                            "invalid instance of 'string id'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("Var(...) argument 2: " +
                            "invalid instance of 'int? lineno'")
        if not (self.t is None or isinstance(self.t, type)):
            raise TypeError("Var(...) argument 3: " +
                            "invalid instance of 'type? t'")


@_attrs.define
class StructAccess(expr):
    struct: expr
    member_id: str
    lineno: _Optional[int] = None
    t: _Optional[type] = None

    def __attrs_post_init__(self):
        if not isinstance(self.struct, expr):
            raise TypeError("StructAccess(...) argument 1: " +
                            "invalid instance of 'expr struct'")
        if not isinstance(self.member_id, str):
            raise TypeError("StructAccess(...) argument 2: " +
                            "invalid instance of 'string member_id'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("StructAccess(...) argument 3: " +
                            "invalid instance of 'int? lineno'")
        if not (self.t is None or isinstance(self.t, type)):
            raise TypeError("StructAccess(...) argument 4: " +
                            "invalid instance of 'type? t'")


@_attrs.define
class ConstFloat(expr):
    val: float
    lineno: _Optional[int] = None
    t: _Optional[type] = None

    def __attrs_post_init__(self):
        if not isinstance(self.val, float):
            raise TypeError("ConstFloat(...) argument 1: " +
                            "invalid instance of 'float val'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("ConstFloat(...) argument 2: " +
                            "invalid instance of 'int? lineno'")
        if not (self.t is None or isinstance(self.t, type)):
            raise TypeError("ConstFloat(...) argument 3: " +
                            "invalid instance of 'type? t'")


@_attrs.define
class BinaryOp(expr):
    op: bin_op
    left: expr
    right: expr
    lineno: _Optional[int] = None
    t: _Optional[type] = None

    def __attrs_post_init__(self):
        if not isinstance(self.op, bin_op):
            raise TypeError("BinaryOp(...) argument 1: " +
                            "invalid instance of 'bin_op op'")
        if not isinstance(self.left, expr):
            raise TypeError("BinaryOp(...) argument 2: " +
                            "invalid instance of 'expr left'")
        if not isinstance(self.right, expr):
            raise TypeError("BinaryOp(...) argument 3: " +
                            "invalid instance of 'expr right'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("BinaryOp(...) argument 4: " +
                            "invalid instance of 'int? lineno'")
        if not (self.t is None or isinstance(self.t, type)):
            raise TypeError("BinaryOp(...) argument 5: " +
                            "invalid instance of 'type? t'")


@_attrs.define
class Call(expr):
    id: str
    args: list[expr]
    lineno: _Optional[int] = None
    t: _Optional[type] = None

    def __attrs_post_init__(self):
        if not isinstance(self.id, str):
            raise TypeError("Call(...) argument 1: " +
                            "invalid instance of 'string id'")
        if not (isinstance(self.args, (tuple, list))
                and all(isinstance(x, expr) for x in self.args)):
            raise TypeError("Call(...) argument 2: " +
                            "invalid instance of 'expr* args'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("Call(...) argument 3: " +
                            "invalid instance of 'int? lineno'")
        if not (self.t is None or isinstance(self.t, type)):
            raise TypeError("Call(...) argument 4: " +
                            "invalid instance of 'type? t'")


@_attrs.define
class ContExpr(expr):
    a: arg
    captures: list[expr]
    body: _Optional[expr] = None
    lineno: _Optional[int] = None
    t: _Optional[type] = None

    def __attrs_post_init__(self):
        if not isinstance(self.a, arg):
            raise TypeError("ContExpr(...) argument 1: " +
                            "invalid instance of 'arg a'")
        if not (isinstance(self.captures, (tuple, list))
                and all(isinstance(x, expr) for x in self.captures)):
            raise TypeError("ContExpr(...) argument 2: " +
                            "invalid instance of 'expr* captures'")
        if not (self.body is None or isinstance(self.body, expr)):
            raise TypeError("ContExpr(...) argument 3: " +
                            "invalid instance of 'expr? body'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("ContExpr(...) argument 4: " +
                            "invalid instance of 'int? lineno'")
        if not (self.t is None or isinstance(self.t, type)):
            raise TypeError("ContExpr(...) argument 5: " +
                            "invalid instance of 'type? t'")


class arg:

    def __init__(self, *args, **kwargs):
        assert False, "Cannot instantiate arg"


@_attrs.define
class Arg(arg):
    id: str
    t: type

    def __attrs_post_init__(self):
        if not isinstance(self.id, str):
            raise TypeError("Arg(...) argument 1: " +
                            "invalid instance of 'string id'")
        if not isinstance(self.t, type):
            raise TypeError("Arg(...) argument 2: " +
                            "invalid instance of 'type t'")


class type:

    def __init__(self, *args, **kwargs):
        assert False, "Cannot instantiate type"


@_attrs.define
class Float(type):

    def __attrs_post_init__(self):
        pass


@_attrs.define
class Struct(type):
    id: str
    members: list[struct_member]
    lineno: _Optional[int] = None

    def __attrs_post_init__(self):
        if not isinstance(self.id, str):
            raise TypeError("Struct(...) argument 1: " +
                            "invalid instance of 'string id'")
        if not (isinstance(self.members, (tuple, list))
                and all(isinstance(x, struct_member) for x in self.members)):
            raise TypeError("Struct(...) argument 2: " +
                            "invalid instance of 'struct_member* members'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("Struct(...) argument 3: " +
                            "invalid instance of 'int? lineno'")


@_attrs.define
class Cont(type):
    arg_type: type

    def __attrs_post_init__(self):
        if not isinstance(self.arg_type, type):
            raise TypeError("Cont(...) argument 1: " +
                            "invalid instance of 'type arg_type'")


class struct_member:

    def __init__(self, *args, **kwargs):
        assert False, "Cannot instantiate struct_member"


@_attrs.define
class MemberDef(struct_member):
    id: str
    t: type

    def __attrs_post_init__(self):
        if not isinstance(self.id, str):
            raise TypeError("MemberDef(...) argument 1: " +
                            "invalid instance of 'string id'")
        if not isinstance(self.t, type):
            raise TypeError("MemberDef(...) argument 2: " +
                            "invalid instance of 'type t'")


class bin_op:

    def __init__(self, *args, **kwargs):
        assert False, "Cannot instantiate bin_op"


@_attrs.define
class Add(bin_op):

    def __attrs_post_init__(self):
        pass


@_attrs.define
class Sub(bin_op):

    def __attrs_post_init__(self):
        pass


@_attrs.define
class Mul(bin_op):

    def __attrs_post_init__(self):
        pass


@_attrs.define
class Div(bin_op):

    def __attrs_post_init__(self):
        pass
