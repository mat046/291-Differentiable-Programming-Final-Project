"""
ASDL Module generated by asdl_adt
Original ASDL description:

module floma {
 func = FunctionDef ( string id, arg* args, stmt body, type? ret_type )
      | ReverseDiff ( string id, string primal_func )
      attributes  ( int? lineno )

 stmt = CallStmt ( expr call )
        attributes  ( int? lineno )

 expr = Var          ( string id )
      | ConstFloat   ( float val )
      | Call         ( string id, expr* args )
      attributes     ( int? lineno, type? t )

 arg  = Arg ( string id, type? t)

 type = Float  ( )
}

"""
from __future__ import annotations
import attrs as _attrs
from typing import Tuple as _Tuple
from typing import Optional as _Optional


def _list_to_tuple(xs):
    return tuple(xs) if isinstance(xs, list) else xs


class func:

    def __init__(self, *args, **kwargs):
        assert False, "Cannot instantiate func"


@_attrs.define(frozen=True)
class FunctionDef(func):
    id: str
    args: _Tuple[arg] = _attrs.field(converter=_list_to_tuple)
    body: stmt
    ret_type: _Optional[type] = None
    lineno: _Optional[int] = None

    def __new__(cls, id, args, body, ret_type=None, lineno=None):
        return super().__new__(cls)

    def __attrs_post_init__(self):
        if not isinstance(self.id, str):
            raise TypeError("FunctionDef(...) argument 1: " +
                            "invalid instance of 'string id'")
        if not (isinstance(self.args, (tuple, list))
                and all(isinstance(x, arg) for x in self.args)):
            raise TypeError("FunctionDef(...) argument 2: " +
                            "invalid instance of 'arg* args'")
        if not isinstance(self.body, stmt):
            raise TypeError("FunctionDef(...) argument 3: " +
                            "invalid instance of 'stmt body'")
        if not (self.ret_type is None or isinstance(self.ret_type, type)):
            raise TypeError("FunctionDef(...) argument 4: " +
                            "invalid instance of 'type? ret_type'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("FunctionDef(...) argument 5: " +
                            "invalid instance of 'int? lineno'")


@_attrs.define(frozen=True)
class ReverseDiff(func):
    id: str
    primal_func: str
    lineno: _Optional[int] = None

    def __new__(cls, id, primal_func, lineno=None):
        return super().__new__(cls)

    def __attrs_post_init__(self):
        if not isinstance(self.id, str):
            raise TypeError("ReverseDiff(...) argument 1: " +
                            "invalid instance of 'string id'")
        if not isinstance(self.primal_func, str):
            raise TypeError("ReverseDiff(...) argument 2: " +
                            "invalid instance of 'string primal_func'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("ReverseDiff(...) argument 3: " +
                            "invalid instance of 'int? lineno'")


class stmt:

    def __init__(self, *args, **kwargs):
        assert False, "Cannot instantiate stmt"


@_attrs.define(frozen=True)
class CallStmt(stmt):
    call: expr
    lineno: _Optional[int] = None

    def __new__(cls, call, lineno=None):
        return super().__new__(cls)

    def __attrs_post_init__(self):
        if not isinstance(self.call, expr):
            raise TypeError("CallStmt(...) argument 1: " +
                            "invalid instance of 'expr call'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("CallStmt(...) argument 2: " +
                            "invalid instance of 'int? lineno'")


class expr:

    def __init__(self, *args, **kwargs):
        assert False, "Cannot instantiate expr"


@_attrs.define(frozen=True)
class Var(expr):
    id: str
    lineno: _Optional[int] = None
    t: _Optional[type] = None

    def __new__(cls, id, lineno=None, t=None):
        return super().__new__(cls)

    def __attrs_post_init__(self):
        if not isinstance(self.id, str):
            raise TypeError("Var(...) argument 1: " +
                            "invalid instance of 'string id'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("Var(...) argument 2: " +
                            "invalid instance of 'int? lineno'")
        if not (self.t is None or isinstance(self.t, type)):
            raise TypeError("Var(...) argument 3: " +
                            "invalid instance of 'type? t'")


@_attrs.define(frozen=True)
class ConstFloat(expr):
    val: float
    lineno: _Optional[int] = None
    t: _Optional[type] = None

    def __new__(cls, val, lineno=None, t=None):
        return super().__new__(cls)

    def __attrs_post_init__(self):
        if not isinstance(self.val, float):
            raise TypeError("ConstFloat(...) argument 1: " +
                            "invalid instance of 'float val'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("ConstFloat(...) argument 2: " +
                            "invalid instance of 'int? lineno'")
        if not (self.t is None or isinstance(self.t, type)):
            raise TypeError("ConstFloat(...) argument 3: " +
                            "invalid instance of 'type? t'")


@_attrs.define(frozen=True)
class Call(expr):
    id: str
    args: _Tuple[expr] = _attrs.field(converter=_list_to_tuple)
    lineno: _Optional[int] = None
    t: _Optional[type] = None

    def __new__(cls, id, args, lineno=None, t=None):
        return super().__new__(cls)

    def __attrs_post_init__(self):
        if not isinstance(self.id, str):
            raise TypeError("Call(...) argument 1: " +
                            "invalid instance of 'string id'")
        if not (isinstance(self.args, (tuple, list))
                and all(isinstance(x, expr) for x in self.args)):
            raise TypeError("Call(...) argument 2: " +
                            "invalid instance of 'expr* args'")
        if not (self.lineno is None or isinstance(self.lineno, int)):
            raise TypeError("Call(...) argument 3: " +
                            "invalid instance of 'int? lineno'")
        if not (self.t is None or isinstance(self.t, type)):
            raise TypeError("Call(...) argument 4: " +
                            "invalid instance of 'type? t'")


class arg:

    def __init__(self, *args, **kwargs):
        assert False, "Cannot instantiate arg"


@_attrs.define(frozen=True)
class Arg(arg):
    id: str
    t: _Optional[type] = None

    def __new__(cls, id, t=None):
        return super().__new__(cls)

    def __attrs_post_init__(self):
        if not isinstance(self.id, str):
            raise TypeError("Arg(...) argument 1: " +
                            "invalid instance of 'string id'")
        if not (self.t is None or isinstance(self.t, type)):
            raise TypeError("Arg(...) argument 2: " +
                            "invalid instance of 'type? t'")


class type:

    def __init__(self, *args, **kwargs):
        assert False, "Cannot instantiate type"


@_attrs.define(frozen=True)
class Float(type):

    def __new__(cls):
        return super().__new__(cls)

    def __attrs_post_init__(self):
        pass
